# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""Unittests for tvm.script.ir_builder.tir"""
import pytest
import tvm
from tvm import tir
from tvm.script.ir_builder import tir as T
from tvm.script.ir_builder import IRBuilder
from tvm.ir.base import assert_structural_equal


def test_ir_builder_tir_assert():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.Assert(T.var("int32", name="a") == 0, message="a is 0"):
            T.evaluate(0)
    # the assert generated by IRBuilder
    assert_actual = ib.get()

    # the expected assert statement
    assert_expected = tir.AssertStmt(T.var("int32", name="a") == 0,
                                     tir.StringImm("a is 0"),
                                     tir.Evaluate(0))
    # Check if the generated ir is expected
    assert_structural_equal(assert_actual, assert_expected, map_free_vars=True)


def test_ir_builder_tir_evaluate():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        T.evaluate(0)
    # the evaluate generated by IRBuilder
    eval_actual = ib.get()

    # the expected evaluate
    eval_expected = tir.Evaluate(0)
    # Check if the generated ir is expected
    assert_structural_equal(eval_actual, eval_expected, map_free_vars=True)


def test_ir_builder_tir_let():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.let(T.var("int32", name="a"), tir.IntImm("int32", 2)):
            T.evaluate(0)
    # the let binding generated by IRBuilder
    let_actual = ib.get()

    # the expected Let statement
    let_expected = tir.LetStmt(T.var("int32", name="a"), tir.IntImm("int32", 2), tir.Evaluate(0))
    assert_structural_equal(let_actual, let_expected, map_free_vars=True)


def test_ir_builder_tir_realize():
    buffer_a = T.buffer_decl((128, 128), "float32")
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.realize(buffer_a[0:128, 0:128], "test_storage_scope", True):
            T.evaluate(0)
    realize_actual = ib.get()

    # the expected buffer realization
    buffer_realize = tir.BufferRealize(buffer_a,
                                       [tvm.ir.Range(0, 128),tvm.ir.Range(0, 128)],
                                       True, tir.Evaluate(0))
    expected_realize = tir.AttrStmt(buffer_a, "realize_scope",
                                    tir.StringImm("test_storage_scope"),
                                    buffer_realize)
    assert_structural_equal(realize_actual, expected_realize, map_free_vars=True)


def test_ir_builder_tir_thread():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.prim_func():
            brow = T.env_thread("blockIdx.y")
            with T.launch_thread(brow, 1):
                T.evaluate(0)
    ir_actual = ib.get()
    iter_var =  tir.IterVar((0, 1), "v", iter_type=1, thread_tag="blockIdx.y")
    attr_stmt = tir.AttrStmt(iter_var, "thread_extent", 1, tir.Evaluate(0))
    func = tir.PrimFunc([], attr_stmt)
    assert_structural_equal(ir_actual, func, map_free_vars=True)


if __name__ == "__main__":
    pytest.main([__file__])
