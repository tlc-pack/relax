# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""Unittests for tvm.script.ir_builder.tir"""
import pytest
import numpy as np
import tvm
from tvm import tir
from tvm.runtime import ndarray
from tvm.script.ir_builder import tir as T
from tvm.script.ir_builder import IRBuilder
from tvm.ir.base import assert_structural_equal


def test_ir_builder_tir_assert():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.Assert(T.var("int32", name="a") == 0, message="a is 0"):
            T.evaluate(0)
    # the assert generated by IRBuilder
    assert_actual = ib.get()

    # the expected assert statement
    assert_expected = tir.AssertStmt(
        T.var("int32", name="a") == 0, tir.StringImm("a is 0"), tir.Evaluate(0)
    )
    # Check if the generated ir is expected
    assert_structural_equal(assert_actual, assert_expected, map_free_vars=True)


def test_ir_builder_tir_evaluate():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        T.evaluate(0)
    # the evaluate generated by IRBuilder
    eval_actual = ib.get()

    # the expected evaluate
    eval_expected = tir.Evaluate(0)
    # Check if the generated ir is expected
    assert_structural_equal(eval_actual, eval_expected, map_free_vars=True)


def test_ir_builder_tir_let():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.let(T.var("int32", name="a"), tir.IntImm("int32", 2)):
            T.evaluate(0)
    # the let binding generated by IRBuilder
    let_actual = ib.get()

    # the expected Let statement
    let_expected = tir.LetStmt(T.var("int32", name="a"), tir.IntImm("int32", 2), tir.Evaluate(0))
    assert_structural_equal(let_actual, let_expected, map_free_vars=True)


def test_ir_builder_tir_realize():
    buffer_a = T.buffer_decl((128, 128), "float32")
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.realize(buffer_a[0:128, 0:128], "test_storage_scope", True):
            T.evaluate(0)
    realize_actual = ib.get()

    # the expected buffer realization
    buffer_realize = tir.BufferRealize(
        buffer_a, [tvm.ir.Range(0, 128), tvm.ir.Range(0, 128)], True, tir.Evaluate(0)
    )
    expected_realize = tir.AttrStmt(
        buffer_a, "realize_scope", tir.StringImm("test_storage_scope"), buffer_realize
    )
    assert_structural_equal(realize_actual, expected_realize, map_free_vars=True)


def test_ir_builder_tir_thread():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.prim_func():
            brow = T.env_thread("blockIdx.y")
            with T.launch_thread(brow, 1):
                T.evaluate(0)
    ir_actual = ib.get()
    iter_var = tir.IterVar((0, 1), "v", iter_type=1, thread_tag="blockIdx.y")
    attr_stmt = tir.AttrStmt(iter_var, "thread_extent", 1, tir.Evaluate(0))
    func = tir.PrimFunc([], attr_stmt)
    assert_structural_equal(ir_actual, func, map_free_vars=True)


def test_ir_builder_tir_allocate():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.allocate([10], "float32", scope="local"):
            T.evaluate(1)
    ir_actual = ib.get()
    buffer_var = tir.Var("v", tvm.ir.PointerType(tvm.ir.PrimType("float32"), "local"))
    ir_expected = tir.Allocate(
        buffer_var, "float32", [10], tvm.tir.const(1, "uint1"), tir.Evaluate(1)
    )
    assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


def test_ir_builder_tir_allocate_const():
    data = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.allocate_const(data, "int32", [10]):
            T.evaluate(1)
    ir_actual = ib.get()
    buffer_var = tir.Var("v", tvm.ir.PointerType(tvm.ir.PrimType("int32")))
    ir_expected = tir.AllocateConst(
        buffer_var, "int32", [10], ndarray.array(np.asarray(data, "int32")), tir.Evaluate(1)
    )
    assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


def test_ir_builder_tir_prefetch():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        buffer_a = T.buffer_decl((128, 128), "float32")
        T.prefetch(buffer_a, [])
    ir_actual = ib.get()
    ir_expected = tir.Prefetch(buffer_a, [])
    assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


def test_ir_builder_tir_buffer_store():
    buffer_a = T.buffer_decl((10, 10), "float32")
    i = T.var("int32", "x")
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        T.buffer_store(buffer_a, 0.1, [0, i])
    ir_actual = ib.get()
    ir_expected = tir.BufferStore(buffer_a, 0.1, [0, i])
    assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


def test_ir_builder_tir_while():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.While(T.var("int32", "x") > 0):
            T.evaluate(0)
    ir_actual = ib.get()
    ir_expected = tir.While(tir.Var("x", "int32") > 0, tir.Evaluate(0))
    assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


def test_ir_builder_tir_if():
    with IRBuilder() as ib:  # pylint: disable=invalid-name
        with T.If(T.var("int32", "c") < 12):
            with T.Then():
                T.int32(0)
            with T.Else():
                T.int32(1)
    ir_actual = ib.get()
    ir_expected = tir.if_then_else(
        tir.Var("c", "int32") < 12, tir.IntImm("int32", 0), tir.IntImm("int32", 1)
    )
    # comment this assertion because tir does not have if/then/else
    # assert_structural_equal(ir_actual, ir_expected, map_free_vars=True)


if __name__ == "__main__":
    pytest.main([__file__])
